@startuml scripts-domain-model

hide empty members
package Repository{
    interface Repository<Id, Entity>
}

package "Users management" as UsersManagement {
    interface UsersService <<Service>>
}

package "Devices management" as DevicesManagement {
    interface DevicesService <<Service>>
    interface DeviceEventsService <<Service>>
    interface DeviceEventsSubscriber
}

package Permissions {
    interface PermissionsService <<Service>>
}

package Notifications {
    interface NotificationsService <<Service>>
}

package "Scripts" {

    interface ScriptId

    interface Script<Id extends ScriptId> <<Aggregate>> {
        id: Id
        name: String
        ~execute(): Async<ExecutionEnvironment | ScriptError>
    }

    interface Task {
        ~execute(Token): Async<ExecutionEnvironment | ScriptError>
    }
    interface Automation {
        enabled: Boolean
    }

    interface Trigger

    struct DeviceEventTrigger extends Trigger {
        deviceId: DeviceId
        eventName: String
    }

    struct PeriodTrigger extends Trigger {
        start: DateTime
        periodSeconds: Long
    }

    interface Instruction {
        ~execute(ExecutionEnvironment): Async<ExecutionEnvironment | ScriptError>
    }
    class StartTaskInstruction extends Instruction {
        taskId: TaskId
    }

    class DeviceActionInstruction extends Instruction {
        deviceId: DeviceId
        actionId: DeviceActionId
        input: Any
    }

    class IfInstruction

    class IfElseInstruction

    class SendNotificationInstruction extends Instruction {
        email: Email
        message: String
    }

    class WaitInstruction extends Instruction {
        seconds: Long
    }

    interface ConstantInstruction<T> {
        name: String
        type: Type<T>
    }

    class CreateDevicePropertyConstantInstruction<T> extends ConstantInstruction {
        deviceId: DeviceId
        propertyId: DevicePropertyId
    }

    class CreateConstantInstruction<T> extends ConstantInstruction {
        value: T
    }

    interface Condition<T> {
        leftConstant: ConstantInstruction<T>
        rightConstant: ConstantInstruction<T>
        negate: Boolean
        ~evaluate(ExecutionEnvironment): Boolean
    }

    interface ConditionOperator<T> {
        ~evaluate(ConstantValue<T>, ConstantValue<T>): Boolean
    }

    note right of ConditionOperator
        instaces of this interface will be:
        IntEOperator
        IntGEOperator
        IntLEOperator
        IntGOperator
        IntLOperator

        (And same of Int for Double)

        StringEOperator

        ColorEOperator

        BooleanEOperator
    end note

    interface ExecutionEnvironment {
        taskToken: Token?
    }

    struct ConstantValue<T> {
        value: T
    }

    ExecutionEnvironment "0..*" -- "0..*" ConstantInstruction
    ConstantValue .. (ExecutionEnvironment, ConstantInstruction)

    ~interface ScriptRepository<ScriptId, Script> <<Repository>> {
    }
    ScriptRepository -l-|> Repository.Repository
    ScriptRepository o-- Script

    interface ScriptsService <<Service>> {
        findTask(Token, TaskId): Task | InvalidTokenError | ScriptNotFoundError
        getAllTasks(Token): Iterable<Task> | InvalidTokenError
        createTask(Token, TaskBuilder): TaskId | InvalidTokenError | TaskNameAlreadyInUseError | InvalidScriptError
        editTask(Token, TaskId, TaskBuilder): (InvalidTokenError | PermissionError | ScriptNotFoundError | InvalidScriptError | TaskNameAlreadyInUseError)?
        startTask(Token, TaskId): (InvalidTokenError | ScriptNotFoundError | PermissionError)?
        removeTask(Token, TaskId): (InvalidTokenError | ScriptNotFoundError | PermissionError)?
        ..
        findAutomation(Token, AutomationId): Automation | InvalidTokenError | ScriptNotFoundError
        getAllAutomations(Token): Iterable<Automation> | InvalidTokenError
        createAutomation(Token, AutomationBuilder): AutomationId | InvalidTokenError | AutomationNameAlreadyInUseError | InvalidScriptError | PermissionError
        editAutomation(Token, AutomationId, AutomationBuilder): (InvalidTokenError | PermissionError | ScriptNotFoundError | InvalidScriptError | AutomationNameAlreadyInUseError)?
        setAutomationState(Token, AutomationId, enable: Boolean): (InvalidTokenError | ScriptNotFoundError)?
        removeAutomation(Token, AutomationId): (InvalidTokenError | ScriptNotFoundError | PermissionError)?
    }

    note left of ScriptsService::startTask
        internally creates a new thread 
        which will run the task
    end note

    Script -l[hidden] ScriptId
    Script <|-- Task : "<TaskId>"
    Script <|--- Automation : "<AutomationId>"
    Automation "1" -- "1" Trigger
    Script "1" -r- "0..*" Instruction : "{ordered}"
    IfInstruction --u-|> Instruction
    IfElseInstruction -l-|> IfInstruction
    IfInstruction "0..1" o-u- "0..*" Instruction : "then >"
    IfInstruction "1" -- "1" Condition
    IfElseInstruction "0..1" o-u- "0..*" Instruction : "else >"
    Condition "0..*" -- "1" ConditionOperator
    ConstantInstruction -l-|> Instruction
    ScriptsService --> ScriptRepository
    ScriptsService -u-> Permissions.PermissionsService
    ScriptsService -u-> DevicesManagement.DevicesService
    ScriptsService -u-> DevicesManagement.DeviceEventsService
    ScriptsService -u-|> DevicesManagement.DeviceEventsSubscriber
    ScriptsService -u-> UsersManagement.UsersService
    Script -u-> Notifications.NotificationsService
    Script -u-> ScriptsService
    Script -l-> Permissions.PermissionsService
    Script -u-> DevicesManagement.DevicesService
}

@enduml
